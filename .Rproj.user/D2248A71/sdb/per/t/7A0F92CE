{
    "contents" : "## server app for shiny to create plots based on inputs from ui\n## data are loaded from .Rdata file\n## Load libraries\n\nrequire(shiny)\nrequire(ggplot2)\nrequire(mapproj)\nrequire(plyr)\nrequire(scales)\nrequire(rworldmap)\n\n\n## Load data, specify path when needed\nload(file = \"../DATA/MWTL_Noordzee_bewerkt.Rdata\")\nload(file = \"../DATA/map.rdata\")\n\nalllocs <- as.character(unique(rws_dat$locatie))\nalllocmap <- subset(locmap, locmap$LOCOMSCH %in% alllocs)\n\n## Define a server for the Shiny app\nshinyServer(function(input, output) {\n  ## Select data that meet the criteria defined in the UI\n  output$timePlot <- renderPlot({\n    subdf = subset(rws_dat, rws_dat$variable == input$substance &  #\"phosphate\" &\n                     rws_dat$locatie == input$location &   #  \"Groote Gat noord\" &\n                     rws_dat$year >= input$interval[1] &\n                     rws_dat$year <= input$interval[2])\n    unit = unique(subdf$eenheid)\n    \n    ## Create statistics information needed in the plot annotation\n    if(input$analysis == \"trend\") {\n      x = as.numeric(subdf$datetime); y = subdf$waarde    \n      regression <- summary(glm(y ~ x + I(cos(2 * pi * x / 31556995)) + I(sin(2 * pi * x / 31556995))))\n      slope <- regression$coefficients[2,1]  #slope of regression including season effect\n      pvalue <- format(regression$coefficients[2,4], digits = 2)\n      intercept <- regression$coefficients[[1]]\n    }\n    \n    ## make parameters for positioning of plot annotation\n    minscale <- min(subdf$datetime)\n    maxscale <- max(subdf$datetime)\n    yposition <- quantile(subdf$waarde, 0.99, na.rm = T)\n    #     q90 <- function(x) {quantile(x,probs=0.9)}\n    \n    subdf_year <- ddply(subdf, ~ year + season, summarize, perc = quantile(waarde, probs = 0.9, na.rm = T))\n    subdf_year$year <- as.POSIXct(paste(as.character(subdf_year$year), \"-07-01 00:00:00\", sep = \"\"))\n    \n    summer90 <- quantile(subset(subdf, subdf$season == \"summer\", na.rm = T)$waarde,  probs = 0.9, na.rm = T)\n    winter90 <- quantile(subset(subdf, subdf$season == \"winter\", na.rm = T)$waarde,  probs = 0.9, na.rm = T)\n    \n    ## create plot \n    pl <- ggplot(subdf, aes(datetime, waarde))\n    pl <- pl + facet_grid(variable ~ locatie, scales = \"free\")\n    #            pl <- pl + geom_smooth(aes(color = season) , method=\"lm\", size = 2)\n    if(input$analysis == \"trend\") {   # in case trend is choice of analysis\n      pl <- pl + geom_point(aes(), color = \"seagreen4\", alpha = 0.5)\n      pl <- pl + geom_smooth(aes(), method='lm', \n                             formula = y ~ x+I(cos(2*pi*x/31622400))+I(sin(2*pi*x/31622400)), \n                             size = 0.7, alpha = 0.3, n = 1000)\n      pl <- pl + geom_abline(intercept = intercept, slope = slope , color = \"darkblue\", size = 1)\n      pl <- pl + annotate(\"text\", label = paste(\"slope =\", format(slope*31622400, digits = 2), unit, \"per year | \", \"p=\", pvalue),\n                          x = maxscale - 0.5 * (maxscale - minscale), y = yposition)\n    }\n    if(input$analysis == \"per90\") {  # in case 90 percentile is choice of analysis\n      pl <- pl + geom_point(aes(color = season), size = 2, alpha = 0.4)\n      pl <- pl + geom_crossbar(data = subdf_year, aes(year, perc, color = season), size = 0.75, ymin =F, ymax = F)\n      #       pl <- pl + geom_hline(yintercept = summer90, color = \"orange\", size = 1, alpha = 0.5)\n      #       pl <- pl + geom_hline(yintercept = winter90, color = \"turquoise4\", size = 1, alpha = 0.5)\n    }\n    if(input$analysis == \"loess\") {   # in case trend is choice of analysis\n      pl <- pl + geom_point(aes(), color = \"seagreen4\", alpha = 0.5)\n      pl <- pl + geom_smooth(aes(), method='loess', span = input$lspan, size = 1)\n    }\n    \n    pl <- pl + theme(text = element_text(size = 16), legend.position = \"bottom\")\n    pl <- pl + scale_x_datetime(minor_breaks = date_breaks(\"1 year\"))\n    pl <- pl + xlab(\"date\") + ylab(unit)\n    if(input$substance == \"chlorofyl-a\"){\n      pl <- pl + scale_y_log10()\n    }\n    print(pl)\n  })\n  output$boxPlot <- renderPlot({\n    \n    ## Select data that meet the criteria defined in the UI\n    subdf = subset(rws_dat, rws_dat$variable == input$substance &\n                     rws_dat$locatie == input$location &\n                     rws_dat$waarde < 500 &\n                     rws_dat$year >= input$interval[1] &\n                     rws_dat$year <= input$interval[2])\n    unit = unique(subdf$eenheid)\n    \n    minscale <- min(subdf$datetime)\n    maxscale <- max(subdf$datetime)\n    \n    summer90 <- quantile(subset(subdf, subdf$season == \"summer\")$waarde,  probs = 0.9)\n    winter90 <- quantile(subset(subdf, subdf$season == \"winter\")$waarde,  probs = 0.9)\n    subdf_season <- ddply(subdf, ~ season, summarize, perc = quantile(waarde, probs = 0.9))\n    \n    ## Create plot\n    q <- ggplot(subdf,aes(month,waarde))\n    if(input$analysis == \"trend\") {   # in case trend is choice of analysis\n      q <- q + geom_jitter(position = position_jitter(width = .5), colour = \"seagreen4\", alpha = 0.3)\n      q <- q + geom_boxplot(outlier.colour = \"orange\", alpha = 0.5, color = \"orange\", notch = F, notchwidth = 0.5, outlier.size = F)\n      q <- q + geom_smooth(aes(group = 1), method='lm', formula = y ~ I(cos(2*pi*x/12))+I(sin(2*pi*x/12)), size = 0.7, alpha = 0.2)\n    }\n    if(input$analysis == \"per90\") {  # in case 90 percentile is choice of analysis\n      #       q <- q + geom_violin(outlier.colour = \"orange\", alpha = 0.5, color = \"orange\", notch = F, notchwidth = 0.5)\n      q <- q + geom_jitter(aes(color = season), position = position_jitter(width = .5), alpha = 0.6)\n      q <- q + geom_hline(data = subdf_season, aes(yintercept = perc, color = season), size = 0.75, ymin =F, ymax = F)\n      #       q <- q + geom_hline(yintercept = summer90, color = \"orange\", size = 1, alpha = 0.5)\n      #       q <- q + geom_hline(yintercept = winter90, color = \"turquoise4\", size = 1, alpha = 0.5)\n    }\n    if(input$analysis == \"loess\") {   # in case trend is choice of analysis\n      q <- q + geom_jitter(position = position_jitter(width = .5), colour = \"seagreen4\", alpha = 0.3)\n      q <- q + geom_violin(outlier.colour = \"orange\", alpha = 0.5, color = \"orange\", notch = F, notchwidth = 0.3)\n    }\n    q <- q + facet_grid(variable ~ locatie, scales = \"free\")\n    q <- q + theme(text = element_text(size = 16), legend.position = \"bottom\") +\n      xlab(\"month\") + ylab(unit)\n    if(input$substance == \"chlorofyl-a\"){\n      q <- q + scale_y_log10()\n    }\n    print(q)  \n  })\n  \n  output$map <- renderPlot({\n    ## Select data that meet the criteria defined in the UI\n    maploc   <-   input$location\n    locmapsub  <- subset(locmap, locmap$LOCOMSCH == maploc)\n    \n    ## Create map\n    data(countriesLow)\n    world <- fortify(countriesLow)\n    \n    map <- ggplot() + \n      geom_polygon(data = world, \n                   aes(x=long, y=lat, group=group), \n                   color = \"lightgrey\", fill = \"darkgrey\")\n    \n    xxlim <- c(-2,8)\n    yylim <- c(51.2,55.5)\n    \n    map +\n      coord_map(\"orthographic\", xlim = xxlim, ylim = yylim, orientation=c(55, 10, 0)) +\n      geom_point(aes(X_WGS, Y_WGS), data = alllocmap, alpha = 0.4, size = 3, color = \"blue\") +\n      geom_point(aes(X_WGS, Y_WGS), data = locmapsub, size = 8, color = \"red\") +\n      geom_text(aes(X_WGS, Y_WGS, label = LOCOMSCH),hjust = 1, vjust = 0, data = locmapsub, size = 4) +\n      theme(axis.text = element_blank(),\n            axis.title = element_blank(),\n            axis.line = element_blank(),\n            axis.ticks = element_blank())\n    \n  })\n  \n})\n",
    "created" : 1444142716883.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2646465698",
    "id" : "7A0F92CE",
    "lastKnownWriteTime" : 1446467792,
    "path" : "D:/GitHubClones/ShinyMeetNoordzee/R/server.R",
    "project_path" : "R/server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}